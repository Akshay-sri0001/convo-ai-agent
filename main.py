# main.py (Updated with Google Calendar API integration)
import uvicorn
from fastapi import FastAPI, HTTPException, Request, Depends
from pydantic import BaseModel
from typing import List, Dict, Any, Optional, TypedDict, Annotated
import datetime
from contextlib import asynccontextmanager
import os
import json

# LangChain and LangGraph imports
from langchain_core.messages import BaseMessage, HumanMessage, AIMessage, ToolMessage
from langchain_core.tools import tool
from langchain_core.prompts import ChatPromptTemplate, MessagesPlaceholder
from langchain_google_genai import ChatGoogleGenerativeAI
from langgraph.graph import StateGraph, END
from langgraph.prebuilt import ToolExecutor, ToolNode

# Google API imports
from google.oauth2.credentials import Credentials
from google.auth.transport.requests import Request as GoogleAuthRequest # Renamed to avoid conflict with FastAPI Request
from googleapiclient.discovery import build
from googleapiclient.errors import HttpError

# --- FastAPI App Initialization ---
# This part remains the same.
app = FastAPI(
    title="Conversational AI Booking Agent with Google Calendar",
    description="Backend API for a conversational AI agent to book appointments using Google Calendar.",
    version="1.0.0"
)

# --- Configuration for Google Calendar API ---
# IMPORTANT: For this demo, you need to manually get a refresh token.
# In a production app, you would implement the full OAuth 2.0 flow.
#
# REPLACE THESE WITH YOUR ACTUAL VALUES FROM `client_secret_YOUR_CLIENT_ID.apps.googleusercontent.com.json`
# These are placeholder values.
# If CLIENT_SECRETS_JSON is not set, it means the user has not configured the backend.
# In a real app, this would be loaded from a secure file or environment variable.
# For this demo, we will expose an endpoint to configure these.
CLIENT_SECRETS = {
    "web": { # Even if you chose desktop app, it typically comes under "web" in the JSON structure from Credentials download
        "client_id": "YOUR_CLIENT_ID_FROM_GOOGLE_CLOUD.apps.googleusercontent.com",
        "project_id": "YOUR_PROJECT_ID",
        "auth_uri": "https://accounts.google.com/o/oauth2/auth",
        "token_uri": "https://oauth2.googleapis.com/token",
        "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
        "client_secret": "YOUR_CLIENT_SECRET_FROM_GOOGLE_CLOUD",
        "redirect_uris": [
            "http://localhost" # Desktop app redirects often use localhost
        ]
    }
}

SCOPES = ['https://www.googleapis.com/auth/calendar'] # Scope for full calendar access

# In-memory storage for user tokens. In a real app, use Firestore or a secure database.
# Each session_id will store its own Google Calendar credentials.
user_calendar_credentials: Dict[str, Dict[str, Any]] = {}

# --- Data Models (same as before) ---
class Message(BaseModel):
    role: str
    content: str

class ChatRequest(BaseModel):
    session_id: str
    message: str

class ChatResponse(BaseModel):
    session_id: str
    reply: str
    status: str = "success"

class Appointment(BaseModel):
    id: Optional[str] = None # ID is generated by Google Calendar
    title: str
    start_time: datetime.datetime
    end_time: datetime.datetime
    attendees: List[str] = []
    description: Optional[str] = None

class CalendarConfig(BaseModel):
    """Model for receiving Google Calendar configuration from frontend."""
    refresh_token: str
    client_id: str
    client_secret: str

# --- Google Calendar API Service Initialization ---
async def get_google_calendar_service(session_id: str) -> Any:
    """
    Initializes and returns a Google Calendar API service object for a given session.
    Manages access token refresh using the stored refresh token.
    """
    creds_data = user_calendar_credentials.get(session_id)

    if not creds_data:
        raise HTTPException(status_code=400, detail="Google Calendar not configured for this session. Please configure it first.")

    try:
        # Load credentials from stored data
        creds = Credentials.from_authorized_user_info(
            info={
                "client_id": creds_data.get("client_id"),
                "client_secret": creds_data.get("client_secret"),
                "refresh_token": creds_data.get("refresh_token")
            },
            scopes=SCOPES
        )

        # If the access token is expired or about to expire, refresh it
        if not creds.valid and creds.refresh_token:
            print(f"Refreshing token for session {session_id}...")
            creds.refresh(GoogleAuthRequest())
            # Update stored credentials with new access token
            user_calendar_credentials[session_id]["token"] = creds.token
            user_calendar_credentials[session_id]["expiry"] = creds.expiry.isoformat()
            print(f"Token refreshed for session {session_id}.")

        elif not creds.valid and not creds.refresh_token:
             raise HTTPException(status_code=401, detail="No valid refresh token found. Please re-authenticate.")

        service = build('calendar', 'v3', credentials=creds)
        return service
    except Exception as e:
        print(f"Error getting Google Calendar service for session {session_id}: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to initialize Google Calendar service: {e}")

# --- Tool Functions (Now using Google Calendar API) ---

@tool("check_calendar_availability", args_schema=Appointment)
async def check_calendar_availability_tool(
    start_time: str,
    end_time: str,
    session_id: str = "mock_user" # This default is just for schema, actual value comes from state
) -> Dict[str, Any]:
    """
    Checks if a given time slot is available in the Google Calendar for a specific session.
    Input times must be in ISO 8601 format (e.g., "2025-07-01T10:00:00").
    Returns True if available, False otherwise, along with details.
    """
    try:
        service = await get_google_calendar_service(session_id)
        
        start_dt = datetime.datetime.fromisoformat(start_time)
        end_dt = datetime.datetime.fromisoformat(end_time)

        # Convert to RFC3339 format required by Google Calendar API
        time_min = start_dt.isoformat() + 'Z'
        time_max = end_dt.isoformat() + 'Z'

        events_result = service.events().list(
            calendarId='primary',
            timeMin=time_min,
            timeMax=time_max,
            singleEvents=True,
            orderBy='startTime'
        ).execute()
        events = events_result.get('items', [])

        if not events:
            return {"status": "success", "available": True, "message": "The time slot appears to be free."}
        else:
            occupied_events = []
            for event in events:
                event_start = event['start'].get('dateTime', event['start'].get('date'))
                event_end = event['end'].get('dateTime', event['end'].get('date'))
                occupied_events.append({
                    "summary": event.get('summary', 'No Title'),
                    "start": event_start,
                    "end": event_end
                })
            return {"status": "success", "available": False, "message": "The time slot is occupied.", "occupied_events": occupied_events}

    except HttpError as error:
        print(f"An HTTP error occurred: {error}")
        return {"status": "error", "message": f"Failed to check availability due to Google API error: {error.content.decode()}"}
    except HTTPException as e:
        # Re-raise HTTPException from get_google_calendar_service for proper frontend display
        raise e
    except Exception as e:
        print(f"An unexpected error occurred in check_calendar_availability_tool: {e}")
        return {"status": "error", "message": f"An unexpected error occurred: {str(e)}"}

@tool("book_appointment", args_schema=Appointment)
async def book_appointment_tool(
    title: str,
    start_time: str,
    end_time: str,
    attendees: Optional[List[str]] = None,
    description: Optional[str] = None,
    session_id: str = "mock_user"
) -> Dict[str, Any]:
    """
    Books an appointment in the Google Calendar for a specific session.
    Input times must be in ISO 8601 format (e.g., "2025-07-01T10:00:00").
    Returns a dictionary with booking details on success, or an error message.
    """
    try:
        service = await get_google_calendar_service(session_id)

        start_dt = datetime.datetime.fromisoformat(start_time)
        end_dt = datetime.datetime.fromisoformat(end_time)

        # Check availability first (optional, but good practice)
        availability_check = await check_calendar_availability_tool(start_time=start_time, end_time=end_time, session_id=session_id)
        if not availability_check.get("available", False):
            return {"status": "error", "message": "Cannot book: The time slot is already occupied or an error occurred during availability check."}

        event = {
            'summary': title,
            'description': description,
            'start': {
                'dateTime': start_dt.isoformat(),
                'timeZone': 'UTC', # Or dynamically get user's timezone
            },
            'end': {
                'dateTime': end_dt.isoformat(),
                'timeZone': 'UTC', # Or dynamically get user's timezone
            },
            'attendees': [{'email': email} for email in (attendees if attendees else [])],
            'reminders': {
                'useDefault': False,
                'overrides': [
                    {'method': 'email', 'minutes': 24 * 60},
                    {'method': 'popup', 'minutes': 10},
                ],
            },
        }

        created_event = service.events().insert(calendarId='primary', body=event).execute()
        return {
            "status": "success",
            "message": "Appointment booked successfully!",
            "event_id": created_event['id'],
            "htmlLink": created_event['htmlLink'],
            "summary": created_event['summary'],
            "start": created_event['start'].get('dateTime', created_event['start'].get('date')),
            "end": created_event['end'].get('dateTime', created_event['end'].get('date'))
        }

    except HttpError as error:
        print(f"An HTTP error occurred: {error}")
        return {"status": "error", "message": f"Failed to book appointment due to Google API error: {error.content.decode()}"}
    except HTTPException as e:
        # Re-raise HTTPException from get_google_calendar_service for proper frontend display
        raise e
    except Exception as e:
        print(f"An unexpected error occurred in book_appointment_tool: {e}")
        return {"status": "error", "message": f"An unexpected error occurred: {str(e)}"}

# --- LangGraph Agent Setup (same as before, but tools are async now) ---

# Define the tools available to the agent
tools = [check_calendar_availability_tool, book_appointment_tool]
tool_executor = ToolExecutor(tools)

# Define the graph state
class AgentState(TypedDict):
    messages: Annotated[List[BaseMessage], lambda x, y: x + y]
    session_id: str

# Initialize the LLM (Gemini 2.0 Flash)
llm = ChatGoogleGenerativeAI(model="gemini-2.0-flash", google_api_key="")
llm_with_tools = llm.bind_tools(tools)

# Define nodes for the graph
def agent_node(state: AgentState):
    """
    The main agent node responsible for calling the LLM.
    It takes the current state (messages) and uses the LLM to decide the next action.
    """
    messages = state["messages"]
    session_id = state["session_id"]
    print(f"Agent Node - Current Session ID: {session_id}")

    # Add a system message to guide the LLM
    system_message_content = (
        "You are a helpful conversational AI assistant that specializes in managing Google Calendar appointments. "
        "Your primary goal is to assist users in checking calendar availability and booking appointments using Google Calendar. "
        "When checking availability or booking, ensure you get all necessary details like date, start time, and end time. "
        "Use the 'check_calendar_availability_tool' and 'book_appointment_tool' functions as needed. "
        "Always confirm details with the user before attempting to book. "
        "If the user asks for tomorrow, assume the next day from the current date. "
        "Current date is: " + datetime.datetime.now().strftime("%Y-%m-%d") + ". "
        "Always respond politely and clearly. If you need to tell the user to configure Google Calendar, mention it."
    )

    prompt = ChatPromptTemplate.from_messages(
        [
            ("system", system_message_content),
            MessagesPlaceholder(variable_name="messages"),
        ]
    )
    chain = prompt | llm_with_tools
    response = chain.invoke({"messages": messages})
    return {"messages": [response]}

async def tool_node(state: AgentState):
    """
    The tool node responsible for executing the tools.
    It takes the tool calls generated by the LLM and executes them.
    Note: Tools are now async, so this function also needs to be async.
    """
    tool_calls = state["messages"][-1].tool_calls
    session_id = state["session_id"]

    responses = []
    for tool_call in tool_calls:
        # Inject session_id into tool arguments
        tool_call['args']['session_id'] = session_id
        print(f"Executing tool: {tool_call['name']} with args: {tool_call['args']}")
        
        try:
            # Execute the tool and capture the output
            # Await the tool_executor.ainvoke call since tools are now async
            tool_output = await tool_executor.ainvoke([tool_call])
            responses.append(ToolMessage(content=str(tool_output), tool_call_id=tool_call['id']))
        except HTTPException as e:
            # Catch specific HTTPException (e.g., "Google Calendar not configured")
            responses.append(ToolMessage(content=f"Error executing tool: {e.detail}", tool_call_id=tool_call['id']))
            print(f"Caught HTTP Exception in tool_node: {e.detail}")
        except Exception as e:
            responses.append(ToolMessage(content=f"Error executing tool: {str(e)}", tool_call_id=tool_call['id']))
            print(f"Caught general Exception in tool_node: {e}")

    return {"messages": responses}

# Define the graph edges (logic for transitions)
def should_continue(state: AgentState) -> str:
    last_message = state["messages"][-1]
    if isinstance(last_message, AIMessage) and last_message.tool_calls:
        return "continue_tool"
    return "end"

# Build the LangGraph
workflow = StateGraph(AgentState)

workflow.add_node("agent", agent_node)
workflow.add_node("tool", tool_node) # Tool node is now async

workflow.set_entry_point("agent")

workflow.add_conditional_edges(
    "agent",
    should_continue,
    {
        "continue_tool": "tool",
        "end": END
    }
)
workflow.add_edge("tool", "agent")

# Compile the graph
agent_executor = workflow.compile()

# --- Store conversational history per session (same as before) ---
session_histories: Dict[str, List[BaseMessage]] = {}

# --- FastAPI App Lifecycle ---
@asynccontextmanager
async def lifespan(app: FastAPI):
    print("FastAPI application starting up with Google Calendar integration...")
    yield
    print("FastAPI application shutting down...")

app = FastAPI(
    title="Conversational AI Booking Agent",
    description="Backend API for a conversational AI agent to book appointments with LangGraph and Google Calendar.",
    version="1.0.0",
    lifespan=lifespan
)

# --- New API Endpoint for Calendar Configuration ---
@app.post("/configure_calendar", status_code=200)
async def configure_calendar(config: CalendarConfig, request: Request):
    """
    Endpoint to receive Google Calendar configuration (refresh token, client_id, client_secret).
    This is for demo purposes to manually provide credentials.
    In a real app, this would be part of a full OAuth 2.0 flow.
    """
    session_id = request.headers.get("X-Session-ID") # Get session ID from custom header
    if not session_id:
        raise HTTPException(status_code=400, detail="Session ID (X-Session-ID header) is required.")

    # Store credentials in our in-memory dictionary
    user_calendar_credentials[session_id] = {
        "refresh_token": config.refresh_token,
        "client_id": config.client_id,
        "client_secret": config.client_secret,
        "token_uri": CLIENT_SECRETS["web"]["token_uri"],
        "scopes": SCOPES
    }
    
    # Try to initialize service immediately to validate credentials
    try:
        service = await get_google_calendar_service(session_id)
        # Attempt a simple API call to verify credentials
        service.calendarList().list().execute()
        return {"status": "success", "message": "Google Calendar configured successfully!"}
    except Exception as e:
        # If verification fails, remove stored credentials and return error
        if session_id in user_calendar_credentials:
            del user_calendar_credentials[session_id]
        print(f"Configuration failed for session {session_id}: {e}")
        raise HTTPException(status_code=400, detail=f"Failed to verify Google Calendar credentials. Please check your token, client ID, and client secret. Error: {str(e)}")


# --- API Endpoints (Updated) ---

@app.post("/chat", response_model=ChatResponse)
async def chat_with_agent(request: ChatRequest):
    """
    Endpoint for sending user messages to the conversational agent.
    This now integrates with the LangGraph agent and uses Google Calendar tools.
    """
    session_id = request.session_id
    user_message_content = request.message

    current_history = session_histories.get(session_id, [])
    current_history.append(HumanMessage(content=user_message_content))

    print(f"Session {session_id} - User Message: {user_message_content}")
    print(f"Session {session_id} - Current History Length: {len(current_history)}")

    try:
        final_state = await agent_executor.ainvoke({"messages": current_history, "session_id": session_id})
        print(f"Session {session_id} - Final State: {final_state}")

        agent_reply_message = final_state["messages"][-1]
        
        if isinstance(agent_reply_message, AIMessage):
            reply_content = agent_reply_message.content
        elif isinstance(agent_reply_message, ToolMessage):
            # If the last message is a ToolMessage (meaning the tool executed and returned something)
            # The agent should ideally process this and then return an AIMessage.
            # If for some reason it ends with ToolMessage, we can return its content.
            reply_content = f"Tool executed: {agent_reply_message.content}"
            print(f"Warning: LangGraph finished with a ToolMessage. This might indicate incomplete processing. Content: {reply_content}")
        else:
            reply_content = "I processed your request, but the agent's final response format was unexpected."
            print(f"Warning: Last message in state was not AIMessage or ToolMessage: {agent_reply_message}")

        session_histories[session_id] = final_state["messages"]
        print(f"Session {session_id} - Updated History Length: {len(session_histories[session_id])}")

        return ChatResponse(session_id=session_id, reply=reply_content)

    except HTTPException as e:
        # Catch explicit HTTPExceptions (like calendar not configured) and relay them
        print(f"HTTPException during agent invocation for session {session_id}: {e.detail}")
        current_history.append(AIMessage(content=f"An error occurred: {e.detail}"))
        session_histories[session_id] = current_history
        return ChatResponse(session_id=session_id, reply=f"An error occurred: {e.detail}", status="error")
    except Exception as e:
        print(f"Error during agent invocation for session {session_id}: {e}")
        current_history.append(AIMessage(content=f"An unexpected error occurred: {str(e)}. Please try again or reconfigure Google Calendar."))
        session_histories[session_id] = current_history
        raise HTTPException(status_code=500, detail=f"Internal server error: {e}")


@app.get("/health")
async def health_check():
    """Health check endpoint."""
    return {"status": "ok"}

# --- How to run the application (for development) ---
# To run this file:
# 1. Save it as `main.py`
# 2. Make sure you have the required packages installed: `pip install -r requirements.txt`
# 3. Run from your terminal: `uvicorn main:app --reload`
# The API will be accessible at http://127.0.0.1:8000
# You can test the /chat endpoint using a tool like Postman or curl.
# Example curl command:
# curl -X POST -H "Content-Type: application/json" -d '{"session_id": "test_session", "message": "Hi, I want to schedule a call for tomorrow afternoon."}' http://127.0.0.1:8000/chat